# Ch3 연산자

### 연산자 우선순위
- 산술 > 비교 > 논리 > 삼항 > 대입
- 쉬프트 연산자 (<<, >>) 는 덧셈 연산자보다 순위가 낮다
- 논리 연산자는 &&가 || 보다 순위가 높다


### 산술 변환
- 두 피연산자의 타입을 같게 일치 시켜야한다 (자동)
    - 리터럴도 마찬가지임
- 피연산자의 타입이 int보다 작은 타입이면 int로 변환한다 (자동)
- 연산결과의 타입은 피연산자의 타입과 동일하게 간다
    - int / int 의 결과에서 소수점 이하도 필요하다면 int / (float)int 로 한쪽을 형변환 해줘서 연산결과도 float가 되도록 해줘야함
    - Math.round(실수); : 소수점 아래 첫째 자리에서 반올림
- 오버플로우도 고려해서 형을 선택해야함

### 비트 연산자
- 비트 논리 연산자: and, or, xor, not -> & , | , ^ , ~
- 비트 쉬프트 연산자: <<, >>
    - *2<sup>n </sup>, /2<sup>n</sup>
    - 연산 속도가 곱하기 나누기 보다 빠름
    - 오른쪽항은 형변환 필요 없음

### 조건 연산자 ? :
(조건식) ? 식1 : 식2
- 조건식이 true면 식1이 연산결과, false면 식2가 연산결과
- 형변환 발생함
- 중첩 가능
    - 잘 쓰면 if문 대체하여 코드 간략화 가능

```java
public class OperatorEx32 {
    public static void main(String[] args) {
        int x, y, z;
        int absX, absY, absZ;
        char signX, signY, signZ;

        x = 10;
        y = -5;
        z = 0;

        absX = x >= 0 ? x : -x;
        absY = y >= 0 ? y : -y;
        absZ = z >= 0 ? z : -z;

        signX = x > 0 ? '+' : (x==0 ? ' ' : '-');
        signY = y > 0 ? '+' : (y==0 ? ' ' : '-');
        signZ = z > 0 ? '+' : (z==0 ? ' ' : '-');

        System.out.printf("x=%c%d%n", signX, absX);
        System.out.printf("y=%c%d%n", signY, absY);
        System.out.printf("z=%c%d%n", signZ, absZ);
    }
}
```
- 변수의 부호를 판단하고 절대값과 부호를 출력하는 함수, 조건 연산자로 절대값과 부호 판단

### Tip
- 논리 연산자(&&, ||)는 왼쪽항에서 오른쪽항으로 판단하기 때문에 왼쪽항이 이미 조건을 만족시키면 오른쪽항은 검사 안함
  -  왼쪽항에 연산을 한번에 끝낼만한 조건을 넣어서 오른쪽항을 검사 안하게끔 해 최적화 가능